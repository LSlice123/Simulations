<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All Simulators Combined</title>
    <style>
        :root {
            --bg: #071016;
            --panel: #0e1622;
            --text-color: #eaf6ff;
            --accent: #2ee6a5;
        }
        body {
            font-family: Inter, system-ui, Arial, sans-serif;
            background: var(--bg);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: var(--accent);
            text-align: center;
            margin-bottom: 20px;
        }
        .simulator-container {
            width: 100%;
            max-width: 1100px;
            margin-bottom: 40px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        h2 {
            font-size: 24px;
            color: var(--text-color);
            background: var(--panel);
            padding: 15px 20px;
            margin: 0;
        }
        iframe {
            width: 100%;
            height: 700px;
            border: none;
            display: block;
            background-color: var(--bg);
        }
    </style>
</head>
<body>

    <h1>Interactive Simulator Suite</h1>

    <div class="simulator-container">
        <h2>1. 3D Radar Dome Simulator</h2>
        <iframe srcdoc="
            <!DOCTYPE html>
            <html lang='en'>
            <head>
            <meta charset='utf-8' />
            <meta name='viewport' content='width=device-width,initial-scale=1,viewport-fit=cover' />
            <title>3D Radar Dome Simulator</title>
            <style>
              :root{
                --bg:#071016;
                --panel:#071c26;
                --accent:#2ee6a5;
                --sweep:#ffd166;
                --muted:#7fb2c9;
              }
              html,body{
                margin:0;padding:0;height:100%;background:linear-gradient(180deg,#02121a 0%, #041827 60%, #071016 100%);
                color:#dff6ee;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;
                -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
              }
              .wrap{max-width:980px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 340px;gap:12px}
              .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.04);border-radius:12px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,0.5)}
              header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
              header h1{font-size:18px;margin:0}
              #canvasWrap{position:relative;display:flex;align-items:center;justify-content:center;min-height:540px}
              canvas{width:100%;height:auto;border-radius:10px;display:block}
              #hud{position:absolute;left:12px;top:12px;background:rgba(2,6,10,0.6);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px}
              .controls{display:flex;flex-direction:column;gap:8px}
              .row{display:flex;gap:8px;align-items:center}
              label{font-size:13px;color:var(--muted);min-width:120px}
              input[type=range]{flex:1}
              button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px;border-radius:8px;cursor:pointer}
              button:active{transform:translateY(1px)}
              .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px}
              .legend span{display:inline-flex;align-items:center;gap:6px}
              .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
              footer{grid-column:1/-1;margin-top:6px;font-size:12px;color:var(--muted);text-align:center}
              @media(max-width:920px){ .wrap{grid-template-columns:1fr; padding:8px} #canvasWrap{min-height:420px} }
            </style>
            </head>
            <body>
              <div class='wrap'>
                <div class='card'>
                  <header>
                    <h1>3D Radar Dome — Interactive Simulator</h1>
                  </header>

                  <div id='canvasWrap'>
                    <canvas id='radar'></canvas>
                    <div id='hud'>Tap to add target • Tap blip to lock • Drag to move • Double-tap to delete</div>
                  </div>

                  <div style='margin-top:10px;display:flex;gap:10px;flex-wrap:wrap'>
                    <button id='addRandom'>Add random target</button>
                    <button id='clearAll'>Clear all</button>
                    <button id='pauseBtn'>Pause</button>
                  </div>
                </div>

                <div class='card controls'>
                  <div class='row'><label>Sweep speed (deg/s)</label><input id='sweepSpeed' type='range' min='20' max='360' value='120'></div>
                  <div class='row'><label>Dome tilt (deg)</label><input id='tilt' type='range' min='0' max='60' value='25'></div>
                  <div class='row'><label>Max range (km)</label><input id='rangeKm' type='range' min='5' max='200' value='40'></div>
                  <div class='row'><label>Clutter (intensity)</label><input id='clutter' type='range' min='0' max='100' value='12'></div>
                  <div class='row'><label>Echo fade (s)</label><input id='fade' type='range' min='0.3' max='3' step='0.1' value='1.2'></div>
                  <div class='row'><label>Max target speed</label><input id='vmax' type='range' min='5' max='250' value='70'></div>

                  <div style='margin-top:6px;color:var(--muted);font-size:13px'>Selected target info shown on lock. Use sliders to modify environment.</div>

                  <div class='legend'>
                    <span><i class='dot' style='background:var(--accent)'></i> Target</span>
                    <span><i class='dot' style='background:#3ec5ff'></i> Locked</span>
                    <span><i class='dot' style='background:var(--sweep)'></i> Sweep</span>
                    <span><i class='dot' style='background:#ff6b6b'></i> Clutter</span>
                  </div>
                </div>

                <footer class='card'>Demo created for SparkX — 3D Radar Dome simulation. Save as <code>radar_dome_3d.html</code> and open in browser. Works offline on phone/laptop.</footer>
              </div>

            <script>
            (() => {
              const canvas = document.getElementById('radar');
              const hud = document.getElementById('hud');
              const ctx = canvas.getContext('2d');

              // controls
              const addRandom = document.getElementById('addRandom');
              const clearAll = document.getElementById('clearAll');
              const pauseBtn = document.getElementById('pauseBtn');
              const sweepSpeedInput = document.getElementById('sweepSpeed');
              const tiltInput = document.getElementById('tilt');
              const rangeKmInput = document.getElementById('rangeKm');
              const clutterInput = document.getElementById('clutter');
              const fadeInput = document.getElementById('fade');
              const vmaxInput = document.getElementById('vmax');

              let DPR = window.devicePixelRatio || 1;
              function resize(){
                const rect = canvas.parentElement.getBoundingClientRect();
                const size = Math.min(rect.width - 6, 900);
                canvas.style.width = size + 'px';
                canvas.style.height = Math.round(size * 0.85) + 'px';
                canvas.width = Math.floor(size * DPR);
                canvas.height = Math.floor(size * 0.85 * DPR);
              }
              window.addEventListener('resize', resize);
              resize();

              // Simulation state
              const state = {
                sweepAngle: 0,                // radians
                sweepSpeed: parseFloat(sweepSpeedInput.value) * Math.PI/180, // rad/s
                tiltDeg: parseFloat(tiltInput.value),
                rangeKm: parseFloat(rangeKmInput.value),
                fade: parseFloat(fadeInput.value),
                clutter: parseFloat(clutterInput.value),
                vmax: parseFloat(vmaxInput.value),
                running: true,
                targets: [],   // {id, az (rad 0..2pi), el (rad 0..pi/2), range (0..1), vxA, vyE, refl}
                echoes: [],    // {x,y,alpha,ts,isNoise,id}
                selectedId: null,
                lastTs: performance.now(),
                fps: 0
              };

              // utils
              const rand = (a,b) => a + Math.random()*(b-a);
              const uid = () => Math.floor(Math.random()*0xFFFFF).toString(16);
              const nowSec = ()=> performance.now()/1000;
              function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
              const TWO_PI = Math.PI*2;

              // Add random target
              function addRandomTarget(){
                const az = rand(0, TWO_PI);
                const el = rand(0.05, 0.9) * (Math.PI/2); // 0 (horizon) .. pi/2 (zenith)
                const r = rand(0.08, 0.95); // normalized radius inside dome
                // small velocity components: angular change and elevation change
                const speedFactor = state.vmax / 100; // relative
                const v_az = rand(-0.02,0.02) * speedFactor;
                const v_el = rand(-0.01,0.01) * speedFactor;
                const refl = clamp(rand(0.3,1.0), 0.15, 1.0);
                const id = uid();
                state.targets.push({id,az,el,r,v_az,v_el,refl,created:nowSec()});
                updateHudCount();
              }

              function clearTargets(){ state.targets = []; state.selectedId = null; state.echoes = []; updateHudCount(); }

              // This function was empty, now it updates the HUD with the number of targets.
              function updateHudCount(){
                const sel = state.targets.find(tt => tt.id === state.selectedId);
                if (!sel){
                  hud.innerHTML = `Targets: ${state.targets.length} • Drag to move • Tap to lock • Double-tap to delete`;
                }
              }

              addRandom.addEventListener('click', ()=> addRandomTarget());
              clearAll.addEventListener('click', ()=> clearTargets());
              pauseBtn.addEventListener('click', ()=>{
                state.running = !state.running;
                pauseBtn.textContent = state.running ? 'Pause' : 'Resume';
              });

              sweepSpeedInput.addEventListener('input', ()=> state.sweepSpeed = parseFloat(sweepSpeedInput.value) * Math.PI/180);
              tiltInput.addEventListener('input', ()=> state.tiltDeg = parseFloat(tiltInput.value));
              rangeKmInput.addEventListener('input', ()=> state.rangeKm = parseFloat(rangeKmInput.value));
              clutterInput.addEventListener('input', ()=> state.clutter = parseFloat(clutterInput.value));
              fadeInput.addEventListener('input', ()=> state.fade = parseFloat(fadeInput.value));
              vmaxInput.addEventListener('input', ()=> state.vmax = parseFloat(vmaxInput.value));

              // interaction helpers (mouse/touch)
              let dragging = null, dragOffset = {x:0,y:0}, lastTap = 0;

              function canvasPos(evt){
                const rect = canvas.getBoundingClientRect();
                let x,y;
                if (evt.touches && evt.touches.length){
                  x = (evt.touches[0].clientX - rect.left) * DPR;
                  y = (evt.touches[0].clientY - rect.top) * DPR;
                } else {
                  x = (evt.clientX - rect.left) * DPR;
                  y = (evt.clientY - rect.top) * DPR;
                }
                return {x,y};
              }

              function pickTargetAt(px,py){
                // find target projecting to 2d and choose nearest
                const p = projectToScreenCenter();
                let best = 30*DPR, picked = null;
                for (const t of state.targets){
                  const proj = projectTarget(t, p.cx, p.cy, p.R);
                  const d = Math.hypot(proj.x - px, proj.y - py);
                  if (d < best){ best = d; picked = t; }
                }
                return picked;
              }

              canvas.addEventListener('mousedown', onDown);
              canvas.addEventListener('touchstart', onDown, {passive:false});
              function onDown(e){
                e.preventDefault();
                const {x,y} = canvasPos(e);
                const now = performance.now();
                const p = pickTargetAt(x,y);
                if (p){
                  if (now - lastTap < 300){
                    // double-tap: delete
                    state.targets = state.targets.filter(t=>t.id!==p.id);
                    if (state.selectedId === p.id) state.selectedId = null;
                  } else {
                    // select and begin drag
                    state.selectedId = p.id;
                    dragging = p.id;
                    dragOffset.x = x; dragOffset.y = y;
                  }
                  lastTap = now;
                } else {
                  // add new target at inverted project: approximate az/el from click
                  const pview = projectToScreenCenter();
                  const nx = (x - pview.cx)/pview.R;
                  const ny = (y - pview.cy)/pview.R;
                  // map back to azimuth/elevation
                  const r2 = Math.hypot(nx, ny);
                  const rnorm = clamp(r2, 0.05, 0.99);
                  const az = Math.atan2(ny, nx);
                  // elevation: smaller y (near center) -> higher elevation; near rim -> low elevation
                  const el = clamp((1 - rnorm) * (Math.PI/2), 0.02, Math.PI/2 - 0.02);
                  const id = uid();
                  const v_az = rand(-0.01,0.01);
                  const v_el = rand(-0.008,0.008);
                  const refl = clamp(rand(0.4,1.0),0.1,1.0);
                  state.targets.push({id,az,el,r:rnorm,v_az,v_el,refl,created:nowSec()});
                  updateHudCount();
                }
              }

              window.addEventListener('mousemove', onMove);
              window.addEventListener('touchmove', onMove, {passive:false});
              function onMove(e){
                if (!dragging) return;
                e.preventDefault();
                const pos = canvasPos(e);
                const pview = projectToScreenCenter();
                // compute target new az/el from mouse pos
                const nx = (pos.x - pview.cx)/pview.R;
                const ny = (pos.y - pview.cy)/pview.R;
                const r2 = Math.hypot(nx, ny);
                const rnorm = clamp(r2, 0.05, 0.99);
                const az = Math.atan2(ny, nx);
                const el = clamp((1 - rnorm) * (Math.PI/2), 0.02, Math.PI/2 - 0.02);
                const t = state.targets.find(tt=>tt.id===dragging);
                if (t){ t.az = az; t.el = el; t.r = rnorm; }
              }

              window.addEventListener('mouseup', ()=> dragging = null);
              window.addEventListener('touchend', ()=> dragging = null);

              // projection utilities to get screen mapping for the dome
              function projectToScreenCenter(){
                const W = canvas.width, H = canvas.height;
                // center and radius for dome projection
                const cx = W * 0.5, cy = H * 0.55;
                const R = Math.min(W, H) * 0.45;
                return {cx, cy, R};
              }

              // project a target with azimuth, elevation, normalized radius -> screen x,y and scale (depth)
              function projectTarget(t, cx, cy, R){
                // spherical coords: az (0..2pi around), el (0..pi/2) from horizon (0) to zenith (pi/2)
                // convert to 3D coordinates on hemisphere of radius R
                const rad = t.r * R;
                // use azimuth as angle in plane, elevation reduces apparent radius
                const px = cx + rad * Math.cos(t.az) * Math.cos(t.el);
                const py = cy + rad * Math.sin(t.az) * Math.cos(t.el) - (Math.sin(t.el) * R * 0.4); // lift towards top for elevation
                // depth factor for size & occlusion: higher elevation -> closer -> larger
                const depth = 0.5 + 0.5 * Math.cos(t.el); // 0..1
                return {x: px, y: py, depth};
              }

              // main loop
              let lastFrame = performance.now(), frameCount=0, fpsTime=performance.now();
              function frame(ts){
                const dt = (ts - lastFrame)/1000;
                lastFrame = ts;
                if (state.running) update(dt);
                draw();
                // fps
                frameCount++;
                if (ts - fpsTime > 500){
                  state.fps = Math.round(frameCount * 1000 / (ts - fpsTime));
                  fpsTime = ts; frameCount = 0;
                }
                requestAnimationFrame(frame);
              }
              requestAnimationFrame(frame);

              function update(dt){
                // rotate sweep
                state.sweepAngle += state.sweepSpeed * dt;
                state.sweepAngle = state.sweepAngle % TWO_PI;

                // move targets a bit (simple angular velocities)
                for (const t of state.targets){
                  t.az += t.v_az * dt * (state.vmax/70); // scale by vmax
                  t.el += t.v_el * dt;
                  // clamp elevation
                  t.el = clamp(t.el, 0.02, Math.PI/2 - 0.02);
                  // small wandering in radius
                  t.r += (Math.sin(nowSec() + parseInt(t.id,16)%10) * 0.0008);
                  t.r = clamp(t.r, 0.03, 0.98);
                }

                // clutter generator: ephemeral noise echoes when sweep passes
                const now = nowSec();
                if (state.clutter > 0){
                  const bits = Math.max(0, Math.floor(state.clutter/8));
                  for (let i=0;i<bits;i++){
                    if (Math.random() < 0.02){
                      // spawn a small noise echo near sweep angle
                      const az = state.sweepAngle + rand(-0.08,0.08);
                      const el = rand(0.02, 1.2);
                      const rr = rand(0.25, 0.95);
                      const pview = projectToScreenCenter();
                      const fake = {x: pview.cx + rr*pview.R*Math.cos(az), y: pview.cy + rr*pview.R*Math.sin(az) - Math.sin(el)*pview.R*0.4};
                      state.echoes.push({x:fake.x,y:fake.y,alpha:0.6,ts:now,isNoise:true});
                    }
                  }
                }

                // check for sweep hits on targets
                const tol = 0.07; // radians tolerance for sweep hit
                const pview = projectToScreenCenter();
                for (const t of state.targets){
                  // target az normalized
                  let d = Math.atan2(Math.sin(t.az - state.sweepAngle), Math.cos(t.az - state.sweepAngle));
                  if (Math.abs(d) < tol){
                    // produce an echo at its screen projection
                    const proj = projectTarget(t, pview.cx, pview.cy, pview.R);
                    state.echoes.push({x:proj.x, y:proj.y, alpha: clamp(0.6 * t.refl, 0.08, 1.0), ts: nowSec(), isNoise:false, id:t.id});
                  }
                }

                // fade echoes
                const fadeS = Math.max(0.1, state.fade);
                state.echoes = state.echoes.filter(e => (now - e.ts) < fadeS);
              }

              function draw(){
                const W = canvas.width, H = canvas.height;
                ctx.clearRect(0,0,W,H);
                const p = projectToScreenCenter();
                const cx = p.cx, cy = p.cy, R = p.R;

                // background radial gradient (dome feel)
                const grd = ctx.createRadialGradient(cx, cy - R*0.2, R*0.05, cx, cy, R);
                grd.addColorStop(0, 'rgba(20,40,40,0.35)');
                grd.addColorStop(1, 'rgba(2,6,10,0.6)');
                ctx.fillStyle = grd;
                ctx.beginPath(); ctx.arc(cx, cy, R*1.05, 0, TWO_PI); ctx.fill();

                // draw range rings (projected)
                ctx.save();
                ctx.lineWidth = 1.2*DPR;
                ctx.strokeStyle = 'rgba(120,200,170,0.12)';
                for (let i=1;i<=4;i++){
                  ctx.beginPath();
                  ctx.ellipse(cx, cy - R*0.12, R*(i/4), R*(i/4)*0.75, 0, 0, TWO_PI);
                  ctx.stroke();
                }
                ctx.restore();

                // draw sweep sector (projected onto dome)
                const tilt = state.tiltDeg * Math.PI/180;
                const sweep = state.sweepAngle;
                // draw faint filled sweep
                ctx.save();
                ctx.beginPath();
                // create many triangular facets to fake dome sweep
                const sweepWidth = 0.18; // radians total wedge
                const left = sweep - sweepWidth/2, right = sweep + sweepWidth/2;
                // create path approximating wedge
                ctx.moveTo(cx, cy);
                const steps = 60;
                for (let i=0;i<=steps;i++){
                  const a = left + (i/steps)*(right-left);
                  const rx = cx + R * Math.cos(a) * Math.cos(tilt);
                  const ry = cy + R * Math.sin(a) * Math.cos(tilt) - Math.sin(tilt)*R*0.2;
                  ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                const grad = ctx.createRadialGradient(cx, cy, 1, cx, cy, R);
                grad.addColorStop(0, 'rgba(255,210,110,0.06)');
                grad.addColorStop(1, 'rgba(255,210,110,0)');
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.restore();

                // draw sweep line
                ctx.save();
                ctx.strokeStyle = 'rgba(255,210,110,0.95)';
                ctx.lineWidth = 2 * DPR;
                ctx.beginPath();
                const sx = cx + R * Math.cos(sweep) * Math.cos(tilt);
                const sy = cy + R * Math.sin(sweep) * Math.cos(tilt) - Math.sin(tilt)*R*0.2;
                ctx.moveTo(cx, cy); ctx.lineTo(sx, sy); ctx.stroke();
                ctx.restore();

                // draw echoes (fading points)
                for (const e of state.echoes){
                  const age = (nowSec() - e.ts) / Math.max(0.001, state.fade);
                  const a = clamp(1 - age, 0, 1) * (e.alpha || 0.7);
                  if (e.isNoise){
                    ctx.fillStyle = `rgba(255,110,110,${a})`;
                  } else {
                    ctx.fillStyle = `rgba(46,230,165,${a})`;
                  }
                  ctx.beginPath(); ctx.arc(e.x, e.y, 4*DPR, 0, TWO_PI); ctx.fill();
                }

                // draw targets (in depth order: low depth first)
                const projected = state.targets.map(t => ({t, p: projectTarget(t, cx, cy, R)}));
                projected.sort((a,b) => a.p.depth - b.p.depth); // far first
                for (const {t,p:proj} of projected){
                  const locked = (state.selectedId === t.id);
                  // halo for locked
                  if (locked){
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(62,197,255,0.9)'; ctx.lineWidth = 2*DPR;
                    ctx.arc(proj.x, proj.y, 10*DPR, 0, TWO_PI); ctx.stroke();
                  }
                  // dot
                  ctx.fillStyle = locked ? 'rgba(62,197,255,1)' : 'rgba(46,230,165,0.95)';
                  const size = 5*DPR * (1 + (1 - proj.depth)*0.6);
                  ctx.beginPath(); ctx.arc(proj.x, proj.y, size, 0, TWO_PI); ctx.fill();
                }

                // HUD info for selected target
                const sel = state.targets.find(tt => tt.id === state.selectedId);
                if (sel){
                  const proj = projectTarget(sel, cx, cy, R);
                  // compute range kms
                  const km = (sel.r * state.rangeKm).toFixed(1);
                  const bearing = ((sel.az * 180/Math.PI) + 360) % 360;
                  const elev = (sel.el * 180/Math.PI).toFixed(0);
                  hud.innerHTML = `<b>LOCK</b><div>Range: ${km} km</div><div>Bearing: ${bearing.toFixed(0)}°</div><div>Elevation: ${elev}°</div><div>Reflectivity: ${(sel.refl*100|0)}%</div>`;
                } else {
                  hud.innerHTML = `Targets: ${state.targets.length} • Tap to add target • Drag to move • Tap blip to lock • Double-tap to delete`;
                }
              }

              // initial demo targets
              for (let i=0;i<4;i++) addRandomTarget();

            })(); // end IIFE
            </script>
            </body>
            </html>
        "></iframe>
    </div>

    <div class="simulator-container">
        <h2>2. Heat-Seeking Missile Simulator</h2>
        <iframe srcdoc="
            <!DOCTYPE html>
            <html lang='en'>
            <head>
            <meta charset='utf-8' />
            <meta name='viewport' content='width=device-width,initial-scale=1' />
            <title>Heat-Seeking Missile Demo</title>
            <style>
              :root{
                --bg:#05060a; --panel:#0b1220; --accent:#ff8c42; --cold:#2bd1ff; --hot:#ff3b3b;
              }
              html,body{height:100%;margin:0;background:linear-gradient(180deg,#02030a 0%, #081024 100%);color:#e6f1ff;font-family:Inter,system-ui,Arial,Helvetica,sans-serif}
              .wrap{max-width:1000px;margin:12px auto;padding:12px;display:grid;grid-template-columns:1fr 320px;gap:12px}
              .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.04);border-radius:10px;padding:12px}
              #canvasWrap{position:relative;min-height:560px;border-radius:8px;overflow:hidden}
              canvas{display:block;width:100%;height:auto;border-radius:8px}
              .controls{display:flex;flex-direction:column;gap:8px}
              .row{display:flex;gap:8px;align-items:center}
              label{min-width:120px;color:#9fb2c9;font-size:13px}
              input[type=range]{flex:1}
              button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px;border-radius:8px;cursor:pointer}
              .legend{display:flex;gap:10px;font-size:12px;color:#94a3b8;margin-top:6px}
              .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
              footer{grid-column:1/-1;text-align:center;color:#8aa4bf;font-size:12px;padding-top:6px}
              @media(max-width:920px){.wrap{grid-template-columns:1fr;}}
            </style>
            </head>
            <body>
              <div class='wrap'>
                <div class='card' id='leftCard'>
                  <h2 style='margin:4px 0 8px 0'>Heat-Seeking Missile Simulator</h2>
                  <div id='canvasWrap'>
                    <canvas id='cv'></canvas>
                    <div id='hud' style='position:absolute;left:12px;top:12px;background:rgba(2,8,14,0.6);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px'>
                      Tap canvas to add a hot target • Add decoys (flares) to mislead seeker
                    </div>
                  </div>
                  <div style='display:flex;gap:8px;margin-top:8px;flex-wrap:wrap'>
                    <button id='btnAddTarget'>Add Random Target</button>
                    <button id='btnAddFlare'>Add Flare (decoy)</button>
                    <button id='btnLaunch'>Launch Missile</button>
                    <button id='btnClear'>Clear All</button>
                    <button id='btnPause'>Pause</button>
                  </div>
                </div>

                <div class='card controls'>
                  <div class='row'><label>Seeker Mode</label>
                    <select id='mode' style='flex:1;padding:8px;border-radius:8px;background:#071827;color:#e6f1ff;border:1px solid rgba(255,255,255,0.04)'>
                      <option value='heat'>IR Heat-Seeker</option>
                      <option value='radar'>Radar-Guided (locks nearest)</option>
                    </select>
                  </div>
                  <div class='row'><label>Missile Speed</label><input id='missSpeed' type='range' min='40' max='400' value='180'></div>
                  <div class='row'><label>Seeker Agility</label><input id='turnRate' type='range' min='0.5' max='10' step='0.1' value='3.2'></div>
                  <div class='row'><label>Sensor Range (px)</label><input id='sensorRange' type='range' min='80' max='1000' value='420'></div>
                  <div class='row'><label>Flare Strength</label><input id='flareStrength' type='range' min='0.2' max='2.0' step='0.1' value='0.9'></div>
                  <div class='row'><label>Ambient Noise</label><input id='noise' type='range' min='0' max='80' value='6'></div>
                  <div style='margin-top:6px;color:#94a3b8;font-size:13px'>Flare decoys temporarily increase apparent heat to try to fool the seeker.</div>
                  <div class='legend'>
                    <span><i class='dot' style='background:var(--hot)'></i> Hot target</span>
                    <span><i class='dot' style='background:#ffd166'></i> Flare (decoy)</span>
                    <span><i class='dot' style='background:var(--cold)'></i> Missile</span>
                  </div>
                </div>

                <footer class='card'>Physics notes: IR seekers detect heat (IR radiation) — they home on the hottest signature. Radar-guided missiles use reflected radio waves. This demo compares both.</footer>
              </div>

            <script>
            (() => {
              const canvas = document.getElementById('cv');
              const hud = document.getElementById('hud');
              const DPR = window.devicePixelRatio || 1;

              function resize(){
                const rect = canvas.parentElement.getBoundingClientRect();
                const W = Math.min(rect.width - 4, 1200);
                canvas.style.width = W + 'px';
                canvas.style.height = Math.round(W * 0.6) + 'px';
                canvas.width = Math.floor(W * DPR);
                canvas.height = Math.floor(W * 0.6 * DPR);
              }
              window.addEventListener('resize', resize);
              resize();
              const ctx = canvas.getContext('2d');

              // controls
              const btnAddTarget = document.getElementById('btnAddTarget');
              const btnAddFlare = document.getElementById('btnAddFlare');
              const btnLaunch = document.getElementById('btnLaunch');
              const btnClear = document.getElementById('btnClear');
              const btnPause = document.getElementById('btnPause');
              const modeSel = document.getElementById('mode');
              const missSpeed = document.getElementById('missSpeed');
              const turnRate = document.getElementById('turnRate');
              const sensorRange = document.getElementById('sensorRange');
              const flareStrength = document.getElementById('flareStrength');
              const noiseSlider = document.getElementById('noise');

              let running = true;
              btnPause.addEventListener('click', ()=> { running = !running; btnPause.textContent = running ? 'Pause' : 'Resume'; });

              // simulation state
              const state = {
                targets: [],   // {x,y,heat,life,type:'target'|'flare'}
                missile: null, // {x,y,vx,vy,speed,angle,active:true}
                time: 0
              };

              // utilities
              const rand = (a,b) => a + Math.random()*(b-a);
              const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
              function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

              // add random hot target
              function addRandomTarget(){
                const W = canvas.width, H = canvas.height;
                const x = rand(60, W-60), y = rand(60, H-60);
                const heat = rand(0.8, 1.6); // relative (higher = hotter)
                state.targets.push({x,y,heat,life:999,type:'target',created:performance.now()});
              }

              function addFlareAt(x,y){
                const strength = parseFloat(flareStrength.value);
                state.targets.push({x,y,heat: 1.0 * strength, life: 1.8, type:'flare', created:performance.now()});
              }

              function clearAll(){ state.targets = []; state.missile = null; }

              btnAddTarget.addEventListener('click', addRandomTarget);
              btnAddFlare.addEventListener('click', ()=>{
                // add flare near center
                addFlareAt(canvas.width*0.5 + rand(-60,60), canvas.height*0.5 + rand(-60,60));
              });
              btnClear.addEventListener('click', clearAll);

              // canvas click interactions: add target on tap
              canvas.addEventListener('click', (ev)=>{
                const rect = canvas.getBoundingClientRect();
                const x = (ev.clientX - rect.left) * DPR;
                const y = (ev.clientY - rect.top) * DPR;
                // add hot target at position
                state.targets.push({x,y,heat: rand(1.0,1.8), life:999, type:'target', created:performance.now()});
              });

              // launch missile from bottom-left corner by default
              btnLaunch.addEventListener('click', ()=>{
                const angle = -Math.PI/8; // slightly upward right
                state.missile = {
                  x: 40 * DPR,
                  y: canvas.height - 40 * DPR,
                  speed: parseFloat(missSpeed.value) * DPR/2,
                  angle: angle,
                  vx: Math.cos(angle), vy: Math.sin(angle),
                  active: true
                };
              });

              // update loop
              let last = performance.now();
              function loop(ts){
                const dt = (ts - last)/1000;
                last = ts;
                if (running) update(dt);
                draw();
                requestAnimationFrame(loop);
              }
              requestAnimationFrame(loop);

              function update(dt){
                state.time += dt;
                // update flares life
                for (let i = state.targets.length-1; i>=0; i--){
                  const t = state.targets[i];
                  if (t.type === 'flare'){
                    t.life -= dt;
                    // flares gradually cool
                    t.heat *= 0.995;
                    if (t.life <= 0) state.targets.splice(i,1);
                  }
                }

                // small noise drift for all heat readings (ambient)
                const ambientNoise = parseFloat(noiseSlider.value) / 200.0;

                // missile homing behavior
                if (state.missile && state.missile.active){
                  const m = state.missile;
                  // find perceived heat for every source within sensor range
                  const sr = parseFloat(sensorRange.value) * DPR;
                  let candidates = [];
                  for (const t of state.targets){
                    const d = Math.hypot(t.x - m.x, t.y - m.y);
                    if (d <= sr){
                      // perceived intensity decays with distance squared (simplified) + ambient noise
                      const perceived = (t.heat / Math.max(1, d*d/(10000))) + (Math.random()*ambientNoise);
                      candidates.push({t,d,perceived});
                    }
                  }

                  let targetChoice = null;
                  if (modeSel.value === 'heat'){
                    // choose highest perceived heat (IR seeker)
                    if (candidates.length > 0){
                      candidates.sort((a,b)=> b.perceived - a.perceived);
                      targetChoice = candidates[0].t;
                    }
                  } else {
                    // radar-guided: choose nearest target
                    if (candidates.length > 0){
                      candidates.sort((a,b)=> a.d - b.d);
                      targetChoice = candidates[0].t;
                    }
                  }

                  // guidance law: turn towards targetChoice with limited turn rate
                  if (targetChoice){
                    const desired = Math.atan2(targetChoice.y - m.y, targetChoice.x - m.x);
                    // normalize angle difference
                    let diff = desired - m.angle;
                    while (diff > Math.PI) diff -= 2*Math.PI;
                    while (diff < -Math.PI) diff += 2*Math.PI;
                    const maxTurn = parseFloat(turnRate.value) * dt; // radians per second scaled by dt
                    const turn = clamp(diff, -maxTurn, maxTurn);
                    m.angle += turn;
                    m.vx = Math.cos(m.angle);
                    m.vy = Math.sin(m.angle);
                  }

                  // advance missile
                  m.x += m.vx * m.speed * dt;
                  m.y += m.vy * m.speed * dt;

                  // check for impact with any target (simple distance)
                  for (let i = state.targets.length-1; i>=0; i--){
                    const t = state.targets[i];
                    const d = Math.hypot(t.x - m.x, t.y - m.y);
                    if (d < 14 * DPR){ // hit: remove target and create explosion visual
                      state.targets.splice(i,1);
                      m.active = false;
                      spawnExplosion(m.x, m.y);
                      break;
                    }
                  }
                  // missile out-of-bounds
                  if (m.x < -50 || m.x > canvas.width+50 || m.y < -50 || m.y > canvas.height+50){
                    m.active = false;
                  }
                }
              }

              // small explosion marker list
              const explosions = [];
              function spawnExplosion(x,y){
                explosions.push({x,y, t:0});
              }

              // draw routine
              function draw(){
                const W = canvas.width, H = canvas.height;
                ctx.clearRect(0,0,W,H);
                // background
                const g = ctx.createLinearGradient(0,0,0,H);
                g.addColorStop(0,'#041022');
                g.addColorStop(1,'#020514');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,W,H);
                // draw heat map from targets (soft glows)
                for (const t of state.targets){
                  const grad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, 80 * DPR);
                  const intensity = clamp(t.heat, 0.1, 2.0); // color mix from cold to hot
                  grad.addColorStop(0, `rgba(255, ${Math.floor(200 - 80*(intensity-0.1))}, 60, ${0.9*intensity})`);
                  grad.addColorStop(0.3, `rgba(255, 140, 60, ${0.5*intensity})`);
                  grad.addColorStop(1, `rgba(8,20,30,0)`);
                  ctx.fillStyle = grad;
                  ctx.beginPath();
                  ctx.arc(t.x, t.y, 110 * DPR * Math.sqrt(intensity), 0, Math.PI*2);
                  ctx.fill();
                }
                // draw ambient noise speckles (small clutter)
                const noise = parseFloat(noiseSlider.value);
                if (noise > 2){
                  const ncount = Math.floor(noise/6);
                  ctx.fillStyle = 'rgba(255,255,255,0.02)';
                  for (let i=0;i<ncount;i++){
                    const px = (i*73*DPR) % W;
                    const py = (i*47*DPR) % H;
                    ctx.fillRect((px + (state.time*25)%100), (py + (state.time*13)%80), 1*DPR, 1*DPR);
                  }
                }
                // draw targets markers and labels
                ctx.font = `${12*DPR}px Arial`;
                ctx.textAlign = 'center';
                for (const t of state.targets){
                  // circular marker
                  ctx.beginPath();
                  ctx.fillStyle = (t.type==='flare') ? 'rgba(255,210,100,0.95)' : 'rgba(255,80,80,0.98)';
                  ctx.arc(t.x, t.y, 6 * DPR, 0, Math.PI*2);
                  ctx.fill();
                  // small label
                  ctx.fillStyle = '#dfefff';
                  ctx.fillText((t.type==='flare' ? 'Flare' : 'Target'), t.x, t.y - 14*DPR);
                }
                // draw missile
                if (state.missile && state.missile.active){
                  const m = state.missile;
                  // missile body
                  ctx.save();
                  ctx.translate(m.x, m.y);
                  ctx.rotate(m.angle);
                  ctx.fillStyle = 'rgba(60,190,255,0.98)';
                  ctx.beginPath();
                  ctx.moveTo(12*DPR,0);
                  ctx.lineTo(-8*DPR, -6*DPR);
                  ctx.lineTo(-8*DPR, 6*DPR);
                  ctx.closePath();
                  ctx.fill();
                  ctx.restore();
                  // seeker sensor range circle
                  ctx.beginPath();
                  ctx.strokeStyle = 'rgba(60,190,255,0.08)';
                  ctx.lineWidth = 1*DPR;
                  ctx.arc(m.x, m.y, parseFloat(sensorRange.value) * DPR, 0, Math.PI*2);
                  ctx.stroke();
                }
                // draw explosions
                for (let i = explosions.length-1; i>=0; i--){
                  const ex = explosions[i];
                  ex.t += 0.03;
                  ctx.beginPath();
                  const r = 18 * DPR * ex.t;
                  ctx.fillStyle = `rgba(255,200,40,${1 - ex.t})`;
                  ctx.arc(ex.x, ex.y, r, 0, Math.PI*2);
                  ctx.fill();
                  if (ex.t > 1) explosions.splice(i,1);
                }
                // HUD: show status
                let hudText = `Targets: ${state.targets.length} • Mode: ${modeSel.value.toUpperCase()} • Missile: ${state.missile && state.missile.active ? 'In flight' : 'Idle'}`;
                hud.innerHTML = hudText + `<br><small>Missile speed & seeker agility set on right. Flares can temporarily fool IR seekers by creating stronger nearby heat signatures.</small>`;
              }
              // helpers
              // seed a couple of targets
              addRandomTarget();
              addRandomTarget();
            })();
            </script>
            </body>
            </html>
        "></iframe>
    </div>
    
    <div class="simulator-container">
        <h2>3. Advanced Interception Simulator (Drone vs Missile)</h2>
        <iframe srcdoc="
            <!DOCTYPE html>
            <html lang='en'>
            <head>
            <meta charset='utf-8'/>
            <meta name='viewport' content='width=device-width,initial-scale=1'/>
            <title>Advanced Interception Simulator (Drone vs Missile)</title>
            <style>
              :root{
                --bg:#0a0f16; --panel:#0e1622; --accent:#2ee6a5; --warn:#ffd166; --danger:#ff6b6b; --info:#7cc0ff;
              }
              html,body{margin:0;height:100%;background:linear-gradient(180deg,#06101a, #09131f);color:#eaf6ff;font-family:Inter,system-ui,Arial}
              .wrap{max-width:1100px;margin:10px auto;padding:10px;display:grid;grid-template-columns:1fr 330px;gap:10px}
              .card{background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));
                    border:1px solid rgba(255,255,255,0.06); border-radius:12px; padding:10px}
              canvas{display:block;width:100%;height:auto;border-radius:10px;background:#050a11}
              h2{margin:4px 0 8px 0;font-weight:600;font-size:18px}
              .row{display:flex;gap:8px;align-items:center;margin:6px 0}
              label{min-width:130px;color:#9ab0c2;font-size:13px}
              input[type=range]{flex:1}
              select,button{padding:8px;border-radius:8px;background:#0b1522;color:#eaf6ff;border:1px solid rgba(255,255,255,0.08);cursor:pointer}
              button:active{transform:translateY(1px)}
              #hud{position:absolute;left:10px;top:10px;background:rgba(5,12,20,0.6);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);font-size:13px}
              .legend{display:flex;gap:10px;font-size:12px;color:#9ab0c2;margin-top:6px;flex-wrap:wrap}
              .badge{display:inline-flex;align-items:center;gap:6px}
              .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
              @media(max-width:980px){.wrap{grid-template-columns:1fr}}
            </style>
            </head>
            <body>
              <div class='wrap'>
                <div class='card'>
                  <h2>Advanced Interception Simulator — Drone vs Missile</h2>
                  <div style='position:relative'>
                    <canvas id='cv'></canvas>
                    <div id='hud'>Click to add/move waypoints • Drag waypoints • Double-click to launch</div>
                  </div>
                  <div style='display:flex;gap:8px;flex-wrap:wrap;margin-top:6px'>
                    <button id='btnLaunch'>Launch Missile</button>
                    <button id='btnReset'>Reset</button>
                    <button id='btnPause'>Pause</button>
                    <button id='btnAddWp'>Add Waypoint</button>
                    <button id='btnClearWp'>Clear Waypoints</button>
                  </div>
                  <div class='legend'>
                    <span class='badge'><i class='dot' style='background:#ff6565'></i> Drone</span>
                    <span class='badge'><i class='dot' style='background:#7cc0ff'></i> Missile</span>
                    <span class='badge'><i class='dot' style='background:#2ee6a5'></i> Predicted Intercept</span>
                    <span class='badge'><i class='dot' style='background:#ffd166'></i> Waypoint</span>
                    <span class='badge'><i class='dot' style='background:#cccccc'></i> Trails</span>
                  </div>
                </div>
            
                <div class='card'>
                  <div class='row'><label>Guidance Law</label>
                    <select id='mode'>
                      <option value='lead'>Lead (analytic)</option>
                      <option value='pursuit'>Pure Pursuit</option>
                      <option value='pn' selected>PN (Proportional Navigation)</option>
                    </select>
                  </div>
                  <div class='row'><label>Nav Constant N (PN)</label><input id='navN' type='range' min='1.5' max='6' step='0.1' value='3.5'></div>
                  <div class='row'><label>Missile: Booster Speed</label><input id='mslBoost' type='range' min='100' max='800' value='420'></div>
                  <div class='row'><label>Missile: Sustain Speed</label><input id='mslSustain' type='range' min='80' max='700' value='320'></div>
                  <div class='row'><label>Max Turn Rate (deg/s)</label><input id='turnRate' type='range' min='30' max='360' value='140'></div>
                  <div class='row'><label>Seeker FOV (deg)</label><input id='fov' type='range' min='10' max='120' value='60'></div>
                  <div class='row'><label>Lock Range (px)</label><input id='lockR' type='range' min='80' max='900' value='520'></div>
                  <div class='row'><label>Booster Time (s)</label><input id='boostTime' type='range' min='0.2' max='4' step='0.1' value='1.2'></div>
                  <div class='row'><label>Drone Speed (px/s)</label><input id='droneV' type='range' min='60' max='400' value='180'></div>
                  <div class='row'><label>Drone Weave (±deg)</label><input id='weave' type='range' min='0' max='25' value='8'></div>
                  <div class='row'><label>Noise (process)</label><input id='noise' type='range' min='0' max='1' step='0.02' value='0.08'></div>
                  <div style='font-size:12px;color:#9ab0c2;margin-top:4px'>PN uses missile turn rate proportional to the rate of change of line-of-sight angle (LOS). Bigger N = more aggressive turns.</div>
                </div>
              </div>
            
            <script>
            (() => {
              const cv = document.getElementById('cv');
              const ctx = cv.getContext('2d');
              const DPR = window.devicePixelRatio || 1;
            
              function resize(){
                const rect = cv.parentElement.getBoundingClientRect();
                const W = Math.min(rect.width, 1100);
                const H = Math.round(W * 0.6);
                cv.style.width = W + 'px';
                cv.style.height = H + 'px';
                cv.width = Math.floor(W * DPR);
                cv.height = Math.floor(H * DPR);
              }
              window.addEventListener('resize', resize);
              resize();
            
              // Controls
              const el = id => document.getElementById(id);
              const modeSel = el('mode'), navN = el('navN'), mslBoost = el('mslBoost'),
                    mslSustain = el('mslSustain'), turnRate = el('turnRate'),
                    fov = el('fov'), lockR = el('lockR'), boostTime = el('boostTime'),
                    droneV = el('droneV'), weave = el('weave'), noise = el('noise');
              const btnLaunch = el('btnLaunch'), btnReset = el('btnReset'), btnPause = el('btnPause'),
                    btnAddWp = el('btnAddWp'), btnClearWp = el('btnClearWp');
            
              let running = true;
              btnPause.addEventListener('click', ()=> { running = !running; btnPause.textContent = running ? 'Pause' : 'Resume'; });
            
              // Scenario state
              const state = {
                t: 0,
                drone: {
                  x: cv.width*0.15, y: cv.height*0.25,
                  heading: Math.PI*0.05,
                  speed: parseFloat(droneV.value)*DPR,
                  weavePhase: 0
                },
                waypoints: [
                  {x: cv.width*0.8, y: cv.height*0.25},
                  {x: cv.width*0.75, y: cv.height*0.55},
                  {x: cv.width*0.2, y: cv.height*0.5}
                ],
                missile: null,
                trails: {drone: [], missile: []},
                impact: null
              };
            
              droneV.addEventListener('input', ()=> state.drone.speed = parseFloat(droneV.value)*DPR);
            
              // Helpers
              const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
              const angNorm = a => {
                while(a>Math.PI) a-=2*Math.PI;
                while(a<-Math.PI) a+=2*Math.PI;
                return a;
              };
              const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
            
              // Waypoint interactions
              let draggingWp = -1;
              cv.addEventListener('mousedown', e=>{
                const p = getPos(e);
                const idx = pickWaypoint(p.x, p.y);
                if (idx>=0){ draggingWp = idx; }
                else {
                  // add a waypoint at click if Add Waypoint mode used
                  if (addWpMode){ state.waypoints.push({x:p.x,y:p.y}); addWpMode=false; btnAddWp.textContent='Add Waypoint'; }
                }
              });
              window.addEventListener('mousemove', e=>{
                if (draggingWp>=0){
                  const p = getPos(e);
                  state.waypoints[draggingWp].x = p.x; state.waypoints[draggingWp].y = p.y;
                }
              });
              window.addEventListener('mouseup', ()=> draggingWp=-1);
              cv.addEventListener('dblclick', ()=> launchMissile()); // quick launch
            
              let addWpMode = false;
              btnAddWp.addEventListener('click', ()=>{ addWpMode = !addWpMode; btnAddWp.textContent = addWpMode? 'Click canvas to place' : 'Add Waypoint'; });
              btnClearWp.addEventListener('click', ()=> state.waypoints = []);
              btnLaunch.addEventListener('click', launchMissile);
              btnReset.addEventListener('click', resetScenario);
            
              function getPos(ev){
                const r = cv.getBoundingClientRect();
                return { x:(ev.clientX - r.left)*DPR, y:(ev.clientY - r.top)*DPR };
              }
              function pickWaypoint(x,y){
                for(let i=0;i<state.waypoints.length;i++){
                  const w=state.waypoints[i]; if (dist(x,y,w.x,w.y)<12*DPR) return i;
                }
                return -1;
              }
            
              function resetScenario(){
                state.t = 0; state.impact = null;
                state.drone = { x: cv.width*0.15, y: cv.height*0.25, heading: Math.PI*0.05, speed: parseFloat(droneV.value)*DPR, weavePhase:0 };
                state.missile = null;
                state.trails = {drone: [], missile: []};
              }
            
              function launchMissile(){
                if (state.missile && state.missile.active) return;
                const m = {
                  x: cv.width*0.1, y: cv.height*0.85,
                  heading: -Math.PI/4,
                  speed: parseFloat(mslBoost.value)*DPR,
                  active: true,
                  booster: parseFloat(boostTime.value),
                  seekerLocked: false
                };
                state.missile = m;
              }
            
              // Lead (analytic) computation for constant-velocity target
              function computeLeadIntercept(mPos, mSpeed, tPos, tVel){
                // Solve mPos + mSpeed*u*dir = tPos + tVel*u for time u, |dir|=1
                const rx = tPos.x - mPos.x, ry = tPos.y - mPos.y;
                const vx = tVel.x, vy = tVel.y;
                const a = (vx*vx + vy*vy) - mSpeed*mSpeed;
                const b = 2*(rx*vx + ry*vy);
                const c = rx*rx + ry*ry;
                let u = null;
                if (Math.abs(a) < 1e-6){
                  if (Math.abs(b) > 1e-6) u = -c/b;
                } else {
                  const disc = b*b - 4*a*c;
                  if (disc >= 0){
                    const u1 = (-b + Math.sqrt(disc))/(2*a);
                    const u2 = (-b - Math.sqrt(disc))/(2*a);
                    u = Math.min(u1,u2); if (u<0) u = Math.max(u1,u2);
                  }
                }
                if (u && u>0){
                  return { x: tPos.x + vx*u, y: tPos.y + vy*u, tgo: u };
                }
                return null;
              }
            
              // Simulation loop
              let last = performance.now();
              function loop(ts){
                const dt = (ts - last)/1000;
                last = ts;
                if (running) update(dt);
                draw();
                requestAnimationFrame(loop);
              }
              requestAnimationFrame(loop);
            
              function update(dt){
                state.t += dt;
            
                // --- Drone kinematics (waypoint following + weave) ---
                const d = state.drone;
                d.speed = parseFloat(droneV.value)*DPR;
            
                let targetHeading = d.heading;
                if (state.waypoints.length){
                  const wp = state.waypoints[0];
                  const ang = Math.atan2(wp.y - d.y, wp.x - d.x);
                  targetHeading = ang;
                  if (dist(d.x,d.y,wp.x,wp.y) < 10*DPR){
                    state.waypoints.push(state.waypoints.shift()); // cycle
                  }
                }
                // small weave (evasive)
                const weaveDeg = parseFloat(weave.value) * (Math.sin(state.t*1.1) + 0.5*Math.sin(state.t*2.3));
                d.weavePhase += dt;
                const weaveRad = weaveDeg * Math.PI/180;
                const desired = angNorm(targetHeading + weaveRad);
                d.heading = angNorm(d.heading + clamp(desired - d.heading, -2*dt, 2*dt));
                d.x += Math.cos(d.heading) * d.speed * dt;
                d.y += Math.sin(d.heading) * d.speed * dt;
                // keep on screen
                d.x = clamp(d.x, 10*DPR, cv.width-10*DPR);
                d.y = clamp(d.y, 10*DPR, cv.height-10*DPR);
            
                // record trail
                if (!state.impact){
                  state.trails.drone.push({x:d.x,y:d.y});
                  if (state.trails.drone.length > 600) state.trails.drone.shift();
                }
            
                // --- Missile guidance ---
                const m = state.missile;
                if (m && m.active){
                  // speed profile
                  if (m.booster > 0){ m.booster -= dt; m.speed = parseFloat(mslBoost.value)*DPR; }
                  else m.speed = parseFloat(mslSustain.value)*DPR;
            
                  const maxTurn = parseFloat(turnRate.value) * Math.PI/180; // rad/s
                  const lockRange = parseFloat(lockR.value) * DPR;
                  const fovRad = parseFloat(fov.value) * Math.PI/180;
            
                  // relative geometry
                  const dx = d.x - m.x, dy = d.y - m.y;
                  const R = Math.hypot(dx,dy);
                  const los = Math.atan2(dy,dx); // line of sight angle
                  const losRateNoise = (Math.random()-0.5) * parseFloat(noise.value); // small jitter
            
                  // seeker lock conditions: within FOV and range
                  const boresightErr = angNorm(los - m.heading);
                  m.seekerLocked = (Math.abs(boresightErr) <= fovRad/2) && (R <= lockRange);
            
                  // target velocity (assume constant during small dt)
                  const tv = { x: Math.cos(d.heading)*d.speed, y: Math.sin(d.heading)*d.speed };
            
                  let desiredHeading = m.heading;
            
                  if (modeSel.value === 'lead'){
                    const sol = computeLeadIntercept({x:m.x,y:m.y}, m.speed, {x:d.x,y:d.y}, tv);
                    if (sol){ desiredHeading = Math.atan2(sol.y - m.y, sol.x - m.x); }
                    else { desiredHeading = los; }
                  }
                  else if (modeSel.value === 'pursuit'){
                    desiredHeading = los; // always point at target
                  }
                  else if (modeSel.value === 'pn'){
                    // PN: turn rate = N * LOS rate (approx with finite difference)
                    const prevLos = m._prevLos ?? los;
                    const losRate = angNorm(los - prevLos)/Math.max(dt,1e-3) + losRateNoise;
                    m._prevLos = los;
                    const N = parseFloat(navN.value);
                    const commanded = clamp(N * losRate, -maxTurn, maxTurn);
                    desiredHeading = m.heading + commanded * dt;
                  }
            
                  // limit turn rate towards desired
                  const dh = angNorm(desiredHeading - m.heading);
                  const limited = clamp(dh, -maxTurn*dt, maxTurn*dt);
                  m.heading = angNorm(m.heading + limited);
            
                  // move
                  m.x += Math.cos(m.heading) * m.speed * dt;
                  m.y += Math.sin(m.heading) * m.speed * dt;
                  state.trails.missile.push({x:m.x,y:m.y});
                  if (state.trails.missile.length > 600) state.trails.missile.shift();
            
                  // impact check
                  if (R < 12*DPR){
                    state.impact = {x:m.x,y:m.y,t:state.t, miss:0};
                    m.active = false;
                    running = false; // auto-pause on hit
                  }
            
                  // miss / out of bounds
                  if (m.x<-30 || m.y<-30 || m.x>cv.width+30 || m.y>cv.height+30){
                    state.impact = {x:m.x,y:m.y,t:state.t, miss:R};
                    m.active = false; running = false;
                  }
                }
              }
            
              function draw(){
                const W=cv.width,H=cv.height;
                // background grid
                ctx.clearRect(0,0,W,H);
                ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=1*DPR;
                for (let x=0;x<W;x+=60*DPR){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
                for (let y=0;y<H;y+=60*DPR){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
            
                // trails
                ctx.lineWidth=1.2*DPR;
                ctx.strokeStyle='rgba(200,200,200,0.35)'; ctx.beginPath();
                for (let i=1;i<state.trails.drone.length;i++){ const a=state.trails.drone[i-1], b=state.trails.drone[i]; ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); }
                ctx.stroke();
                ctx.strokeStyle='rgba(140,210,255,0.35)'; ctx.beginPath();
                for (let i=1;i<state.trails.missile.length;i++){ const a=state.trails.missile[i-1], b=state.trails.missile[i]; ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); }
                ctx.stroke();
            
                // waypoints & path
                if (state.waypoints.length){
                  ctx.strokeStyle='rgba(255,209,102,0.6)'; ctx.lineWidth=1.5*DPR;
                  ctx.beginPath(); ctx.moveTo(state.drone.x, state.drone.y);
                  for (const w of state.waypoints) ctx.lineTo(w.x, w.y);
                  ctx.stroke();
                  for (const w of state.waypoints){
                    ctx.fillStyle='rgba(255,209,102,0.95)'; ctx.beginPath(); ctx.arc(w.x,w.y,5*DPR,0,Math.PI*2); ctx.fill();
                  }
                }
            
                // drone
                drawArrow(state.drone.x, state.drone.y, state.drone.heading, 16*DPR, '#ff6565');
            
                // missile
                if (state.missile){
                  const m = state.missile;
                  // seeker FOV
                  ctx.beginPath();
                  ctx.moveTo(m.x,m.y);
                  const f = parseFloat(fov.value)*Math.PI/180/2;
                  const r = parseFloat(lockR.value)*DPR*0.7;
                  ctx.arc(m.x,m.y,r, m.heading - f, m.heading + f);
                  ctx.closePath();
                  ctx.fillStyle='rgba(124,192,255,0.08)'; ctx.fill();
                  drawArrow(m.x, m.y, m.heading, 14*DPR, '#7cc0ff');
                }
            
                // predicted intercept point (for Lead mode preview)
                if (state.missile && state.missile.active){
                  const m = state.missile, d=state.drone;
                  const tv = { x: Math.cos(d.heading)*d.speed, y: Math.sin(d.heading)*d.speed };
                  const sol = computeLeadIntercept({x:m.x,y:m.y}, m.speed, {x:d.x,y:d.y}, tv);
                  if (sol){
                    ctx.fillStyle='rgba(46,230,165,0.95)';
                    ctx.beginPath(); ctx.arc(sol.x, sol.y, 5*DPR, 0, Math.PI*2); ctx.fill();
                    // dashed helper
                    ctx.setLineDash([6*DPR,6*DPR]); ctx.strokeStyle='rgba(46,230,165,0.4)'; ctx.beginPath();
                    ctx.moveTo(m.x,m.y); ctx.lineTo(sol.x,sol.y); ctx.stroke(); ctx.setLineDash([]);
                  }
                }
            
                // info HUD
                const m = state.missile, d=state.drone;
                const R = m ? dist(m.x,m.y,d.x,d.y) : 0;
                const speedM = m ? (m.speed/DPR)|0 : 0;
                const speedD = (d.speed/DPR)|0;
                const txt = `Mode: ${modeSel.value.toUpperCase()} • R=${R|0}px • Vm=${speedM}px/s • Vt=${speedD}px/s` +
                            (m ? ` • Lock:${m.seekerLocked?'YES':'NO'}` : '') +
                            (state.impact ? ` • ${state.impact.miss===0?'HIT':'MISS '+state.impact.miss.toFixed(0)+' px'}` : '');
                document.getElementById('hud').innerHTML = txt + `<br><small>Double-click canvas or press “Launch Missile”. Drag waypoints to change drone path.</small>`;
              }
            
              function drawArrow(x,y,ang,len,color){
                const w = 6*DPR, t = 10*DPR;
                ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
                ctx.fillStyle=color;
                ctx.beginPath();
                ctx.moveTo(len,0); ctx.lineTo(-len*0.6, -w); ctx.lineTo(-len*0.3, -w);
                ctx.lineTo(-len*0.3, -t); ctx.lineTo(-len*0.8,0);
                ctx.lineTo(-len*0.3, t); ctx.lineTo(-len*0.3, w); ctx.lineTo(-len*0.6, w);
                ctx.closePath(); ctx.fill(); ctx.restore();
              }
            })();
            </script>
            </body>
            </html>
        "></iframe>
    </div>

    <div class="simulator-container">
        <h2>4. Swarm Drone Defense Simulator</h2>
        <iframe srcdoc="
            <!DOCTYPE html>
            <html lang='en'>
            <head>
            <meta charset='utf-8' />
            <meta name='viewport' content='width=device-width,initial-scale=1' />
            <title>Swarm Drone Defense Simulator</title>
            <style>
              :root{
                --bg:#071826; --panel:#0b2a3a; --accent:#2ee6a5; --warn:#ffd166; --danger:#ff6b6b;
                --muted:#9fb6c6;
              }
              html,body{height:100%;margin:0;background:linear-gradient(180deg,#04121a 0%, #071826 100%);color:#e6f7f2;font-family:Inter,system-ui,Arial}
              .wrap{max-width:1100px;margin:12px auto;padding:12px;display:grid;grid-template-columns:1fr 320px;gap:12px}
              .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.04);border-radius:10px;padding:12px}
              canvas{width:100%;height:auto;border-radius:8px;display:block;background:#021722}
              h1{font-size:18px;margin:4px 0 10px 0}
              .controls{display:flex;flex-direction:column;gap:8px}
              .row{display:flex;gap:8px;align-items:center}
              label{min-width:120px;color:var(--muted);font-size:13px}
              input[type=range]{flex:1}
              button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px;border-radius:8px;cursor:pointer}
              .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px;flex-wrap:wrap}
              .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
              footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;padding-top:6px}
              @media(max-width:980px){.wrap{grid-template-columns:1fr}}
            </style>
            </head>
            <body>
              <div class='wrap'>
                <div class='card'>
                  <h1>Swarm Drone Defense Simulator</h1>
                  <canvas id='cv'></canvas>
                  <div style='display:flex;gap:8px;margin-top:8px;flex-wrap:wrap'>
                    <button id='btnSpawnThreat'>Spawn Threat</button>
                    <button id='btnAddSwarm'>Add Drones (+5)</button>
                    <button id='btnRemoveSwarm'>Remove Drones (-5)</button>
                    <button id='btnClear'>Clear All</button>
                    <button id='btnPause'>Pause</button>
                  </div>

                  <div style='margin-top:10px;color:var(--muted);font-size:13px'>
                    Click canvas to place a threat spawn point. Drones will patrol and assigned drones will intercept detected threats.
                  </div>
                  <div style='margin-top:8px' id='stats'></div>
                </div>

                <div class='card controls'>
                  <div class='row'><label>Swarm size</label><input id='swarmSize' type='range' min='5' max='200' value='30'></div>
                  <div class='row'><label>Drone speed</label><input id='droneSpeed' type='range' min='30' max='400' value='170'></div>
                  <div class='row'><label>Sensor range (px)</label><input id='sensorRange' type='range' min='80' max='1000' value='300'></div>
                  <div class='row'><label>Intercept aggressiveness</label><input id='aggressiveness' type='range' min='0.2' max='2.0' step='0.1' value='1.0'></div>
                  <div class='row'><label>Threat speed</label><input id='threatSpeed' type='range' min='30' max='350' value='110'></div>
                  <div class='row'><label>Coverage Est. (sim)</label><input id='coverageSim' type='range' min='0' max='1' step='0.01' value='0.6'></div>

                  <div class='legend'>
                    <span><i class='dot' style='background:#2ee6a5'></i> Defender drone</span>
                    <span><i class='dot' style='background:#ff6969'></i> Incoming threat</span>
                    <span><i class='dot' style='background:#ffd166'></i> Explosion / Intercept</span>
                  </div>
                </div>

                <footer class='card'>Physics: uses kinematics, vector motion, simple pursuit + cooperative assignment. Designed for demonstration and education.</footer>
              </div>

            <script>
            (() => {
              const canvas = document.getElementById('cv');
              const ctx = canvas.getContext('2d');
              const DPR = window.devicePixelRatio || 1;
              function resize(){
                const rect = canvas.parentElement.getBoundingClientRect();
                const W = Math.min(rect.width, 1000);
                const H = Math.round(W * 0.62);
                canvas.style.width = W + 'px';
                canvas.style.height = H + 'px';
                canvas.width = Math.floor(W * DPR);
                canvas.height = Math.floor(H * DPR);
              }
              window.addEventListener('resize', resize);
              resize();

              // controls
              const btnSpawn = document.getElementById('btnSpawnThreat');
              const btnAdd = document.getElementById('btnAddSwarm');
              const btnRm = document.getElementById('btnRemoveSwarm');
              const btnClear = document.getElementById('btnClear');
              const btnPause = document.getElementById('btnPause');
              const swarmSizeInput = document.getElementById('swarmSize');
              const droneSpeedInput = document.getElementById('droneSpeed');
              const sensorRangeInput = document.getElementById('sensorRange');
              const aggressivenessInput = document.getElementById('aggressiveness');
              const threatSpeedInput = document.getElementById('threatSpeed');
              const coverageSimInput = document.getElementById('coverageSim');
              const statsEl = document.getElementById('stats');

              let running = true;
              btnPause.addEventListener('click', ()=> { running = !running; btnPause.textContent = running ? 'Pause' : 'Resume'; });

              // simulation state
              const state = {
                drones: [],    // {x,y,vx,vy,id,assignedId,trail:[]}
                threats: [],   // {x,y,vx,vy,id,life}
                explosions: [],
                t: 0,
                spawnPoints: []
              };

              // utils
              const uid = ()=> Math.floor(Math.random()*1e9).toString(36);
              const rand = (a,b) => a + Math.random()*(b-a);
              const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
              const dist = (a,b) => Math.hypot(a.x-b.x,a.y-b.y);

              // initialize drones
              function initDrones(n){
                state.drones = [];
                for(let i=0;i<n;i++) addDrone(randomPosEdge());
              }

              function addDrone(pos){
                const speed = parseFloat(droneSpeedInput.value) * DPR;
                const angle = Math.random()*Math.PI*2;
                const s = { x: pos.x, y: pos.y, vx: Math.cos(angle), vy: Math.sin(angle), id: uid(), assigned: null, trail: [] };
                state.drones.push(s);
              }

              function randomPosEdge(){
                const W = canvas.width, H = canvas.height;
                const side = Math.floor(Math.random()*4);
                if (side===0) return {x: rand(20*DPR, W-20*DPR), y: 20*DPR};
                if (side===1) return {x: rand(20*DPR, W-20*DPR), y: H-20*DPR};
                if (side===2) return {x: 20*DPR, y: rand(20*DPR, H-20*DPR)};
                return {x: W-20*DPR, y: rand(20*DPR, H-20*DPR)};
              }

              // spawn threat at center top by default or at a spawn point
              function spawnThreatAt(x,y){
                const spd = parseFloat(threatSpeedInput.value) * DPR;
                // choose random direction towards center-ish
                const angle = Math.atan2(canvas.height*0.6 - y, canvas.width*0.5 - x) + rand(-0.6,0.6);
                state.threats.push({ x, y, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd, id: uid(), life: 999 });
              }

              // add some initial swarm and a threat
              initDrones(parseInt(swarmSizeInput.value));
              spawnThreatAt(canvas.width*0.9, canvas.height*0.1);
              spawnThreatAt(canvas.width*0.1, canvas.height*0.05);

              // UI hooks
              btnAdd.addEventListener('click', ()=> {
                for(let i=0;i<5;i++) addDrone(randomPosEdge());
                swarmSizeInput.value = state.drones.length;
              });
              btnRm.addEventListener('click', ()=> {
                for(let i=0;i<5;i++) state.drones.pop();
                swarmSizeInput.value = state.drones.length;
              });
              btnClear.addEventListener('click', ()=> { state.drones=[]; state.threats=[]; state.explosions=[]; });
              btnSpawn.addEventListener('click', ()=> {
                // spawn near top (random)
                const x = rand(60*DPR, canvas.width-60*DPR);
                const y = 20*DPR;
                spawnThreatAt(x,y);
              });

              // click to set spawn point or spawn immediate threat
              canvas.addEventListener('click', (e)=>{
                const r = canvas.getBoundingClientRect();
                const x = (e.clientX - r.left) * DPR;
                const y = (e.clientY - r.top) * DPR;
                spawnThreatAt(x,y);
              });

              // main loop
              let last = performance.now();
              function loop(ts){
                const dt = (ts - last)/1000;
                last = ts;
                if (running) update(dt);
                draw();
                requestAnimationFrame(loop);
              }
              requestAnimationFrame(loop);

              // behavior functions
              function update(dt){
                state.t += dt;
                const W = canvas.width, H = canvas.height;
                const sensorRange = parseFloat(sensorRangeInput.value) * DPR;
                const droneBaseSpeed = parseFloat(droneSpeedInput.value) * DPR;
                const aggressiveness = parseFloat(aggressivenessInput.value);

                // update threats
                for (let i = state.threats.length-1; i>=0; i--){
                  const th = state.threats[i];
                  th.x += th.vx * dt;
                  th.y += th.vy * dt;
                  // bounce off edges a little (or wrap)
                  if (th.x < 10*DPR || th.x > W-10*DPR || th.y < 10*DPR || th.y > H-10*DPR){
                    // remove if out of bounds (threat 'passes through' defended area)
                    state.threats.splice(i,1);
                  }
                }

                // assignment: each threat finds closest available drone within sensor range
                // naive greedy: for each threat, find nearest drone that is not assigned or whose assignment is further away
                for (const th of state.threats){
                  let bestDrone = null, bestDist = Infinity;
                  for (const d of state.drones){
                    const dx = d.x - th.x, dy = d.y - th.y;
                    const dd = Math.hypot(dx,dy);
                    if (dd <= sensorRange){
                      // prefer drones with no assignment or farther assigned threat
                      if (!d.assigned) {
                        if (dd < bestDist){ bestDist = dd; bestDrone = d; }
                      } else if (d.assigned && d.assigned !== th.id){
                        // if currently assigned but this threat is closer than previous, reassign
                        const prev = state.threats.find(t=>t.id===d.assigned);
                        const prevDist = prev ? Math.hypot(d.x-prev.x,d.y-prev.y) : Infinity;
                        if (dd + 5*DPR < prevDist){ bestDist = dd; bestDrone = d; }
                      }
                    }
                  }
                  if (bestDrone){ bestDrone.assigned = th.id; }
                }

                // drones behavior
                for (const d of state.drones){
                  // basic repel from other drones (comfortable spacing)
                  let avoidX = 0, avoidY = 0, neighbors = 0;
                  for (const other of state.drones){
                    if (other === d) continue;
                    const dx = d.x - other.x, dy = d.y - other.y;
                    const dd = Math.hypot(dx,dy) || 1;
                    if (dd < 22*DPR){
                      avoidX += dx / dd;
                      avoidY += dy / dd;
                      neighbors++;
                    }
                  }
                  if (neighbors){
                    avoidX /= neighbors; avoidY /= neighbors;
                  }

                  // patrol behavior if no assignment: gentle wandering or move to center
                  let targetX = canvas.width/2, targetY = canvas.height/2;
                  if (d.assigned){
                    const assignedThreat = state.threats.find(t=>t.id===d.assigned);
                    if (assignedThreat){
                      // pursue assigned threat (intercept style)
                      // guidance: proportional pursuit with aggressiveness factor
                      const pursuitFactor = aggressiveness;
                      const desiredVx = assignedThreat.x - d.x;
                      const desiredVy = assignedThreat.y - d.y;
                      const mag = Math.hypot(desiredVx, desiredVy) || 1;
                      targetX = d.x + (desiredVx / mag) * droneBaseSpeed * pursuitFactor;
                      targetY = d.y + (desiredVy / mag) * droneBaseSpeed * pursuitFactor;
                    } else {
                      d.assigned = null;
                    }
                  } else {
                    // roam near center with some noise
                    targetX = canvas.width*0.5 + Math.cos(state.t + parseInt(d.id,36)%10)*60*DPR;
                    targetY = canvas.height*0.5 + Math.sin(state.t*0.9 + parseInt(d.id,36)%7)*40*DPR;
                  }

                  // combine forces: toTarget + avoidance
                  const toTx = targetX - d.x, toTy = targetY - d.y;
                  let ax = toTx*0.008 + avoidX*0.5;
                  let ay = toTy*0.008 + avoidY*0.5;

                  // velocity update & clamp speed
                  d.vx += ax;
                  d.vy += ay;
                  const vmag = Math.hypot(d.vx,d.vy) || 1;
                  d.vx = (d.vx / vmag) * droneBaseSpeed;
                  d.vy = (d.vy / vmag) * droneBaseSpeed;

                  d.x += d.vx * dt;
                  d.y += d.vy * dt;

                  // add trail
                  d.trail.push({x:d.x,y:d.y});
                  if (d.trail.length > 60) d.trail.shift();
                }

                // collision detection: if a drone is within intercept distance of a threat -> remove threat + explosion
                const interceptDist = 14 * DPR;
                for (let i=state.threats.length-1;i>=0;i--){
                  const th = state.threats[i];
                  for (let j=state.drones.length-1;j>=0;j--){
                    const d = state.drones[j];
                    const dx = th.x - d.x, dy = th.y - d.y;
                    const dd = Math.hypot(dx,dy);
                    if (dd < interceptDist){
                      // intercept occurs
                      state.explosions.push({x: th.x, y: th.y, t:0});
                      // optionally remove drone (simulate damage) or allow reuse; we'll keep drone alive
                      state.threats.splice(i,1);
                      break;
                    }
                  }
                }

                // update explosions
                for (let i=state.explosions.length-1;i>=0;i--){
                  const ex = state.explosions[i];
                  ex.t += dt;
                  if (ex.t > 0.8) state.explosions.splice(i,1);
                }

                // dynamic spawn of threats based on coverageSim probability (optional)
                const coverageParm = parseFloat(coverageSimInput.value);
                if (Math.random() < 0.01 * (1 - coverageParm)) {
                  // occasional extra threat from edges
                  const px = Math.random() < 0.5 ? rand(20*DPR, canvas.width-20*DPR) : (Math.random()<0.5?20*DPR:canvas.width-20*DPR);
                  const py = Math.random() < 0.5 ? 20*DPR : Math.random()*canvas.height*0.2;
                  spawnThreatAt(px,py);
                }
              }

              // draw
              function draw(){
                const W = canvas.width, H = canvas.height;
                // clear
                ctx.clearRect(0,0,W,H);

                // background subtle grid
                ctx.strokeStyle = 'rgba(255,255,255,0.02)';
                for(let gx=0; gx<W; gx+=80*DPR){ ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,H); ctx.stroke(); }
                for(let gy=0; gy<H; gy+=80*DPR){ ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(W,gy); ctx.stroke(); }

                // draw threats (red)
                for (const th of state.threats){
                  ctx.beginPath();
                  ctx.fillStyle = '#ff6969';
                  ctx.arc(th.x, th.y, 8*DPR, 0, Math.PI*2); ctx.fill();
                  // velocity indicator
                  ctx.strokeStyle = 'rgba(255,100,100,0.7)';
                  ctx.beginPath(); ctx.moveTo(th.x, th.y); ctx.lineTo(th.x - th.vx*0.08, th.y - th.vy*0.08); ctx.stroke();
                }

                // draw drone trails
                for (const d of state.drones){
                  if (d.trail.length>1){
                    ctx.beginPath(); ctx.lineWidth = 1 * DPR; ctx.strokeStyle = 'rgba(46,230,165,0.18)';
                    for (let i=1;i<d.trail.length;i++){ ctx.moveTo(d.trail[i-1].x, d.trail[i-1].y); ctx.lineTo(d.trail[i].x, d.trail[i].y); }
                    ctx.stroke();
                  }
                }

                // draw drones
                for (const d of state.drones){
                  ctx.fillStyle = '#2ee6a5';
                  ctx.beginPath(); ctx.arc(d.x, d.y, 6*DPR, 0, Math.PI*2); ctx.fill();
                  // draw small direction indicator
                  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                  ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(d.x - d.vx*0.06, d.y - d.vy*0.06); ctx.stroke();
                  // assigned line
                  if (d.assigned){
                    const assignedThreat = state.threats.find(t=>t.id===d.assigned);
                    if (assignedThreat){
                      ctx.strokeStyle = 'rgba(46,230,165,0.2)';
                      ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(assignedThreat.x, assignedThreat.y); ctx.stroke();
                    } else {
                      // clear stale assignment if threat no longer exists
                      d.assigned = null;
                    }
                  }
                }

                // draw explosions
                for (const ex of state.explosions){
                  const r = 20*DPR * (ex.t*1.6);
                  ctx.beginPath();
                  ctx.fillStyle = `rgba(255,210,100,${1 - ex.t*1.2})`;
                  ctx.arc(ex.x, ex.y, r, 0, Math.PI*2); ctx.fill();
                }

                // HUD / stats
                const drones = state.drones.length;
                const threats = state.threats.length;
                const covers = estimateCoverage();
                statsEl.innerHTML = `<strong>Swarm:</strong> ${drones} drones &nbsp; <strong>Threats:</strong> ${threats} &nbsp; <strong>Coverage est:</strong> ${(covers*100).toFixed(0)}%`;

              }

              // simple coverage estimator: fraction of threats within reachable range of at least one drone
              function estimateCoverage(){
                if (state.threats.length===0) return 1.0;
                const sensorRange = parseFloat(sensorRangeInput.value)*DPR;
                let covered=0;
                for (const th of state.threats){
                  let near=false;
                  for (const d of state.drones){
                    if (Math.hypot(d.x - th.x, d.y - th.y) <= sensorRange*1.1) { near=true; break; }
                  }
                  if (near) covered++;
                }
                return covered / state.threats.length;
              }

              // spawn helper using current threatSpeed
              function spawnThreatAt(x,y){
                const spd = parseFloat(threatSpeedInput.value) * DPR;
                const angle = Math.atan2(canvas.height*0.7 - y, canvas.width*0.5 - x) + rand(-0.6,0.6);
                state.threats.push({x,y,vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd, id: uid(), life:999});
              }

              // init swarm when slider changed
              swarmSizeInput.addEventListener('input', ()=> {
                const desired = parseInt(swarmSizeInput.value);
                const current = state.drones.length;
                if (desired > current){
                  for (let i=0;i<desired-current;i++) addDrone(randomPosEdge());
                } else if (desired < current){
                  for (let i=0;i<current-desired;i++) state.drones.pop();
                }
              });

              // when speed slider changes, keep direction but change magnitude
              droneSpeedInput.addEventListener('input', ()=> {
                const s = parseFloat(droneSpeedInput.value)*DPR;
                for (const d of state.drones){
                  const mag = Math.hypot(d.vx,d.vy) || 1;
                  d.vx = (d.vx / mag) * s;
                  d.vy = (d.vy / mag) * s;
                }
              });

              // random edge pos helper
              function randomPosEdge(){
                const W = canvas.width, H = canvas.height; const side = Math.floor(Math.random()*4);
                if (side===0) return {x: rand(20*DPR, W-20*DPR), y: 20*DPR};
                if (side===1) return {x: rand(20*DPR, W-20*DPR), y: H-20*DPR};
                if (side===2) return {x: 20*DPR, y: rand(20*DPR, H-20*DPR)};
                return {x: W-20*DPR, y: rand(20*DPR, H-20*DPR)};
              }

              // seeded initial state based on slider
              (function seed(){
                state.drones = [];
                const n = parseInt(swarmSizeInput.value);
                for (let i=0;i<n;i++) addDrone(randomPosEdge());
              })();

            })();
            </script>
            </body>
            </html>
        "></iframe>
    </div>
</body>
</html>
